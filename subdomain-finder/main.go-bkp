package main

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"os"
	"text/tabwriter"

	"github.com/miekg/dns"
)

type result struct {
	Hostname string
	IP       string
}

// Struct for worker
type empty struct{}

func worker(tracker chan empty, fqnds chan string, gather chan []result, srvdns string) {

	for fqdn := range fqnds {
		results := resolv(fqdn, srvdns)
		if len(results) > 0 {
			gather <- results
		}

	}
	var e empty
	tracker <- e
}

func resolv(fqdn, dnssrv string) []result {
	// resolve domain, retrieve CNAME and get create a list of IP\

	var results []result
	cfqdn := fqdn

	for {

		cnames, err := resolvCNAME(fqdn, dnssrv)
		if err == nil && len(cnames) > 1 {

			cfqdn = cnames[0]
			continue
		}

		ips, err := resolvArecord(cfqdn, dnssrv)
		if err != nil {
			break
		}

		for _, ip := range ips {
			results = append(results, result{Hostname: fqdn, IP: ip})
		}
		break

	}
	return results
}

func resolvCNAME(fqdn, dnssrv string) ([]string, error) {
	// resolve Canonical names

	var msg dns.Msg
	var fqdns []string

	msg.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)
	r, err := dns.Exchange(&msg, dnssrv)
	if err != nil {
		return fqdns, err
	}
	if len(r.Answer) < 1 {
		return fqdns, errors.New("No CNAME")
	}
	for _, v := range r.Answer {
		if a, ok := v.(*dns.CNAME); ok {
			fqdns = append(fqdns, a.Target)
		}
	}
	return fqdns, nil
}

func resolvArecord(fqdn, dnssrv string) ([]string, error) {
	// resolve name to IP

	var msg dns.Msg
	var ips []string

	msg.SetQuestion(fqdn, dns.TypeA)
	r, err := dns.Exchange(&msg, dnssrv)
	if err != nil {
		return ips, err
	}
	if len(r.Answer) < 1 {
		return ips, errors.New("No records found")
	}
	for _, v := range r.Answer {
		if a, ok := v.(*dns.A); ok {
			ips = append(ips, a.A.String())
		}
	}
	return ips, nil
}

func main() {

	var (
		fgDomain    = flag.String("domain", "", "Target Domain ")
		fgWordlist  = flag.String("wordlist", "", "wordlist fild ")
		fgDNSServer = flag.String("dnsserver", "8.8.8.8:53", "DNS server")
		fgWorker    = flag.Int("c", 100, "Number of worker, default = 100 ")
	)

	flag.Parse()

	if *fgDomain == "" || *fgWordlist == "" {
		fmt.Println("Domain and Wordlist require ... exiting")
		return
	}
	fmt.Println(*fgWorker, *fgDNSServer)

	var results []result
	fqdns := make(chan string, *fgWorker)
	gather := make(chan []result)
	tracker := make(chan empty)

	f, err := os.Open(*fgWordlist)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	Scanner := bufio.NewScanner(f)

	for i := 0; i < *fgWorker; i++ {
		go worker(tracker, fqdns, gather, *fgDNSServer)
	}

	for Scanner.Scan() {
		fqdns <- fmt.Sprintf("%s.%s", Scanner.Text(), *fgDomain)
	}

	go func() {
		for r := range gather {
			results = append(results, r...)
		}
		var e empty
		tracker <- e
	}()

	close(fqdns)
	<-tracker

	w := tabwriter.NewWriter(os.Stdout, 0, 8, 4, ' ', 0)
	for _, r := range results {
		fmt.Fprintf(w, "%s\"%s\n", r.Hostname, r.IP)
	}
	w.Flush()

}
