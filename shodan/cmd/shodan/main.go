package main

import (
	"flag"
	"fmt"
	"golang-projects/pentest-tools/shodan/shodan"
	"log"
	"os"
)

//Global key API variable
var apiKey = os.Getenv("SHODAN_API_KEY")
var s = shodan.New(apiKey)

func main() {

	searchCmd := flag.NewFlagSet("search", flag.ExitOnError)
	searchGet := searchCmd.String("t", "term", "Usage: go-shodan search -t <TERM>. Retrieved information about target")

	subdoCmd := flag.NewFlagSet("sub", flag.ExitOnError)
	subdoGet := subdoCmd.String("d", "domain", "Usage: go-shodan sub -d <Domain>. Enumerate subdomains for target domain name")

	if len(os.Args) < 2 {
		flag.PrintDefaults()
		fmt.Println("Usage: go-shodan <command> [<args>]")
		fmt.Println("	Commands are 'search -t <term> or sub -d <domain>'")
		os.Exit(2)

	}

	switch os.Args[1] {
	//if len(os.Args[1]) < 1 {

	//		}
	case "search":
		searchCmd.Parse(os.Args[2:])
		if searchCmd.Parsed() {
			// Required Flags
			if *searchGet == "" {
				searchCmd.PrintDefaults()
				os.Exit(1)
			}
		}
		ApiStatus()
		Search(*searchGet)

	case "sub":
		subdoCmd.Parse(os.Args[2:])
		if subdoCmd.Parsed() {
			//Required Flags
			if *subdoGet == "" {
				subdoCmd.PrintDefaults()
				os.Exit(1)
			}
		}
		ApiStatus()
		SubdomainEnum(*subdoGet)

	case "default":
		fmt.Println("Usage: go-shodan <command> [<args>]")
		fmt.Println("	Commands are 'search -t <term> or sub -d <domain>'")

	}
}
func ApiStatus() {

	info, err := s.APIInfo()

	if err != nil {
		log.Panicln(err)
	}
	fmt.Printf("\nPlan: %s\nCredits: %d\nScan Credits: %d\n####################################\n", info.Plan, info.QueryCredits, info.ScanCredits)

}

func Search(q string) {

	result, err := s.HostSearch(q)
	if err != nil {
		log.Panicln(err)
	}
	for _, values := range result.Matches {
		//if len(values.IPString) < 1 {
		//	fmt.Println("erffff")
		//}
		fmt.Printf("\n[*] Result:\nOrganisation: %s\nDomains: %s\nLocation: %s\nASN: %s\nIP: %2s  Port:%4d  Protocol: %4s\nProduct: %s\nProduct Version: %s\n",
			values.Org, values.Domains, values.Location.CountryName, values.ASN, values.IPString, values.Port, values.Transport, values.Product, values.ProductVersion)
	}

}

func SubdomainEnum(q string) {

	result, err := s.SubDomains(q)
	if err != nil {
		log.Fatalln(err)
	}
	l := make([]string, 0)

	fmt.Printf("\n[*] Subdomains available for domain %s:\n\n", result.Domain)
	for _, values := range result.SubDomains {
		fmt.Printf("%s.%s\n", values, result.Domain)

	}
}
